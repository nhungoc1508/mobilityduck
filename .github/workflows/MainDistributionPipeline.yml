name: Build & Package DuckDB Extension (linux_amd64_musl)

on:
  push:
    branches:
      - '**'
    tags:
      - 'v*'
  pull_request:
  workflow_dispatch:

jobs:
  linux_amd64_musl:
    runs-on: ubuntu-22.04
    env:
      # ðŸ‘‡ Set your extension folder name (the dir under duckdb/extension/ or your project name)
      EXTENSION_NAME: mobilityduck

    steps:
      - name: Checkout repository (incl. submodules)
        uses: actions/checkout@v4
        with:
          submodules: recursive
          fetch-depth: 0

      - name: Install jq (edit vcpkg.json)
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Cache ccache
        uses: actions/cache@v4
        with:
          path: ccache_dir
          key: ccache-${{ runner.os }}-${{ github.ref_name }}-${{ github.sha }}
          restore-keys: |
            ccache-${{ runner.os }}-${{ github.ref_name }}-
            ccache-${{ runner.os }}-

      - name: Prepare vcpkg (pinned at HEAD)
        run: |
          git clone https://github.com/microsoft/vcpkg.git _vcpkg
          git -C _vcpkg fetch --all --tags
          git -C _vcpkg checkout origin/master
          echo "VCPKG_COMMIT=$(git -C _vcpkg rev-parse HEAD)" >> $GITHUB_ENV

      - name: Ensure vcpkg baseline matches the checkout
        run: |
          if [ -f vcpkg.json ]; then
            tmpfile=$(mktemp)
            jq --arg sha "$VCPKG_COMMIT" '.["builtin-baseline"]=$sha' vcpkg.json > "$tmpfile"
            mv "$tmpfile" vcpkg.json
            echo "Updated vcpkg.json builtin-baseline to $VCPKG_COMMIT"
          else
            echo "No vcpkg.json at repo root; skipping baseline rewrite."
          fi

      - name: Build inside duckdb/linux_amd64_musl
        run: |
          docker run --rm \
            -e VCPKG_ROOT=/work/_vcpkg \
            -e VCPKG_MANIFEST_DIR=/work \
            -e CCACHE_DIR=/ccache_dir \
            -v "$PWD":/work \
            -v "$PWD/ccache_dir":/ccache_dir \
            -v "$PWD/_vcpkg":/work/_vcpkg \
            duckdb/linux_amd64_musl \
            sh -lc '
              set -eux
              # Install ninja + git (Alpine image)
              if command -v apk >/dev/null 2>&1; then
                apk add --no-cache ninja-build git || apk add --no-cache ninja git
              fi

              mkdir -p build/release
              cmake -G "Ninja" \
                -DFORCE_COLORED_OUTPUT=1 \
                -DEXTENSION_STATIC_BUILD=1 \
                -DDUCKDB_EXTENSION_CONFIGS="/work/extension_config.cmake" \
                -DOSX_BUILD_ARCH= \
                -DVCPKG_BUILD=1 \
                -DCMAKE_TOOLCHAIN_FILE="/work/_vcpkg/scripts/buildsystems/vcpkg.cmake" \
                -DVCPKG_TARGET_TRIPLET="x64-linux-release" \
                -DDUCKDB_EXPLICIT_PLATFORM="linux_amd64_musl" \
                -DCUSTOM_LINKER= \
                -DOVERRIDE_GIT_DESCRIBE="" \
                -DUNITTEST_ROOT_DIRECTORY="/work/" \
                -DBENCHMARK_ROOT_DIRECTORY="/work/" \
                -DENABLE_UNITTEST_CPP_TESTS=FALSE \
                -DBUILD_EXTENSION_TEST_DEPS=default \
                -DVCPKG_MANIFEST_DIR="/work" \
                -DCMAKE_BUILD_TYPE=Release \
                -S "/work/duckdb" -B build/release

              cmake --build build/release --config Release

              # Create a staging dir for artifacts
              mkdir -p /work/dist

              # Common locations/patterns where DuckDB extensions end up:
              # 1) The canonical packaged extension format (*.duckdb_extension or zipped variant)
              find build/release -type f \( -name "*.duckdb_extension" -o -name "*.duckdb_extension.gz" -o -name "*.duckdb_extension.zip" \) -print -exec cp {} /work/dist/ \; || true

              # 2) Plain shared libs (if you output them)
              find build/release -type f \( -name "*.so" -o -name "*.dylib" -o -name "*.dll" \) -print -exec cp {} /work/dist/ \; || true

              # 3) Extension subfolder (often build/release/extension/<name>/*)
              if [ -d "build/release/extension/${EXTENSION_NAME}" ]; then
                tar -C build/release/extension -czf "/work/dist/${EXTENSION_NAME}-extension-folder.tar.gz" "${EXTENSION_NAME}" || true
              fi

              # 4) If your build system produces packaged archives somewhere else, copy them too
              find build/release -maxdepth 3 -type f \( -name "*${EXTENSION_NAME}*.zip" -o -name "*${EXTENSION_NAME}*.tar.gz" \) -print -exec cp {} /work/dist/ \; || true

              ls -lah /work/dist || true
            '

      - name: Upload CI artifacts (binaries)
        uses: actions/upload-artifact@v4
        with:
          name: duckdb-extension-binaries-linux-musl
          path: dist/*
          if-no-files-found: warn

      - name: Upload build logs on failure
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: build-logs-linux-musl
          path: |
            build/release/CMakeFiles/CMakeOutput.log
            build/release/CMakeFiles/CMakeError.log
            build/release/vcpkg-manifest-install.log
          if-no-files-found: ignore

      # Optional: attach artifacts to a GitHub Release when building a tag
      - name: Publish release assets
        if: startsWith(github.ref, 'refs/tags/')
        uses: softprops/action-gh-release@v2
        with:
          files: |
            dist/*
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
